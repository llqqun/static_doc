import{_ as t,r as o,o as p,c,b as n,d as e,e as s,a as i}from"./app-1Fk5NupV.js";const r={},l=n("h1",{id:"vue",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#vue","aria-hidden":"true"},"#"),e(" Vue")],-1),d={href:"https://cn.vuejs.org/",target:"_blank",rel:"noopener noreferrer"},u=n("br",null,null,-1),v={href:"https://v2.cn.vuejs.org/v2/guide/",target:"_blank",rel:"noopener noreferrer"},h=i(`<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><h3 id="虚拟-dom-vnode" tabindex="-1"><a class="header-anchor" href="#虚拟-dom-vnode" aria-hidden="true">#</a> 虚拟 DOM ( vnode )</h3><p>虚拟 DOM (Virtual DOM，简称 VDOM) 是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token comment">/* 更多 vnode */</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照不同的类型区分为:</p><blockquote><p>普通元素节点 组件元素节点 纯文本 vnode 注释 vnode</p></blockquote><p>本质上虚拟 DOM 就是一个 javaScript 数据对象 虚拟 DOM 是数据, 真实 DOM 是显示结果,通过虚拟 DOM 去驱动真实 DOM, 这就是数据驱动</p><p>一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为挂载 (mount)。</p><p>如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为更新 (patch)，又被称为“比对”(diffing) 或“协调”(reconciliation)。</p><h2 id="vue3-源码调试" tabindex="-1"><a class="header-anchor" href="#vue3-源码调试" aria-hidden="true">#</a> vue3 源码调试</h2><ol><li>下载源码</li><li>pnpm 安装依赖包</li><li>运行项目<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>npm run dev <span class="token operator">-</span>s
<span class="token comment">// -s 是为了生成source map 文件,更清晰调试</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>运行成功会提示<br><code> watching: packages/vue/dist/vue.global.js</code></li><li>运行测试用例 vue3 测试用例在 vue 文件夹下,也可以自己添加测试文件 通过<code>npm run serve</code>启动测试服务器打开对应测试文件即可</li><li>添加 VS Code 调试 点击左侧调试按钮 点击 <code>Open &#39;launch.json&#39;</code>添加调试文件 打开调试文件后添加调试配置,将上面的测试服务器地址添加到配置的 url 上</li></ol><h2 id="编译系统" tabindex="-1"><a class="header-anchor" href="#编译系统" aria-hidden="true">#</a> 编译系统</h2><h2 id="渲染系统" tabindex="-1"><a class="header-anchor" href="#渲染系统" aria-hidden="true">#</a> 渲染系统</h2><p>创建和渲染<code>vnode</code>过程</p><ol><li><code>ensureRenderer() =&gt; createRenderer() =&gt; baseCreateRenderer()</code>创建 renderer 对象, 调用对象内部函数<code>createApp</code>创建 app 对象</li><li>重写 mount 函数,用户调用</li><li>当 mount 运行时,进行最终挂载时会调用原来的 <code>mount</code>函数进行真正的挂载,创建<code>vnode</code>就是在这里进行</li><li><code>createVNode() =&gt; render() =&gt; patch() = &gt;processComponent =&gt; mountComponent()</code></li></ol><h2 id="vue-响应式原理" tabindex="-1"><a class="header-anchor" href="#vue-响应式原理" aria-hidden="true">#</a> vue 响应式原理</h2><h3 id="vue2-响应式" tabindex="-1"><a class="header-anchor" href="#vue2-响应式" aria-hidden="true">#</a> vue2 响应式</h3><p>依靠 <code>Object.defineProperty()</code> 将对象的属性转换为<code>get/set</code>方式,在属性被修改或者调用时通知变更</p><blockquote><p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。<br> 对象的属性添加和属性删除<br> 数组通过索引下标进行的操作,和数组通过.length 进行的操作</p></blockquote><p>解决方案</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 添加属性</span>
Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> propertyName<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 或</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObject<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 删除属性</span>
Vue<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propertyName <span class="token operator">/</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 数组可以通过splice方法修改length,或进行下标操作</span>
vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>newLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于 Vue 不允许动态添加根级响应式 property，所以必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值 如果未在 data 选项中声明 message，Vue 将警告渲染函数正在试图访问不存在的 property</p><h3 id="vue3-响应式" tabindex="-1"><a class="header-anchor" href="#vue3-响应式" aria-hidden="true">#</a> vue3 响应式</h3><p>通过<code>Proxy</code>的方式代理目标实现了响应式</p><p>注意! Proxy API 并不能深层次监听对象内部变化 vue3 通过 get 中递归的方式进行响应式</p>`,25);function k(m,b){const a=o("ExternalLinkIcon");return p(),c("div",null,[l,n("p",null,[n("a",d,[e("vue3"),s(a)]),e("官方文档"),u,n("a",v,[e("vue2"),s(a)]),e("官方文档")]),h])}const f=t(r,[["render",k],["__file","vue-word.html.vue"]]);export{f as default};
